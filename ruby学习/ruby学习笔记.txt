问题：
1.怎么在ruby中使用数据库

2.ruby中的gem

3.急需要的功能
	1.代码提示功能



1.如何在当前rb源文件中，引用其他的源文件的类及方法
  答：使用require_relative


奇怪的问题
1.定义常量的时候两行不能挨着一起

=======================================


1.理解闭包
  闭包最典型的应用是是实现回掉函数

2.理解回掉函数的意义
  回掉的好处一种一个比如监听器，当按钮点击的时候要出发动作，可是有关按钮的实现流程都是一样的，但是没有事件是不一样的，这个时候就是回掉函数非常方便的地方。
3.多层继承的缺点

4.ruby的反射功能


5.设计模式（重点）

继承使用的方法是：< 

知识点：
1.当调用super而不制定参数时：Ruby向父类发生一条消息，要其调用子类的同名方法
2.一个对象的外部可见部分称为属性
3.attr_reader :name,:ages
4.类变量被所有的对象共享
5.类方法和实例方法的区别，通过在方法前面加上类名，并加上点号定义类方法 
6.类中的方法默认是public的，initialize是private的
7.如果使用反引号`或者%x为前缀的分界符号，括起来一个字符串，默认情况下它会被当着底层操作系统的命令来执行。
8.数组的快速定义方法：a = %w{xxx yyy ddd}
9.在线程中使用print，而不是使用puts，因为puts分为2步，第一步输出信息，第二步输出换行
10.使用反射去检验程序中我们通常看不到的部分


2016-03-17 14:37:24
主要任务：ruby核心部分的ruby语言和分布式ruby
1.symbol是什么东西
 答：比如、attr_accessor :name, :age可以动态的生成方法，其中attr_accessor是Module提供的一个方法
     元编程的反射功能
2.常量和全局变量的作用域区别：

}をhする：
 invalid multibyte char (US-ASCII)の解Q方法はファイルの上にこのような'# encoding=utf-8'を加えてください

2016-03-18 14:43:30
ruby的总结：
1.ruby是一门纯面向对象的编程语言，所有的东西都是对象
2.ruby中有类、模块
3.通常的做法是让一个类对应一个文件
4.模块方法的定义，类似于类方法的定义。使用模块名加句点来调用模块方法，使用模块名和两个冒号来调用常量，模块有另一个妙用，他提供了一种mixin的功能，在类中使用include语句来使用模块，此时模块就变成了类的一个超类的效果
5.类和对象无疑是ruby的核心
6.一个ruby对象有三个部分：一组标志、一些实例变量、以及相关联的类
7.可以使用class <<obj为对象定义一个匿名类，可以使用obj.extend Module来加入一个模块


反射的意义：
  以我的理解来说，反射目前最大的意义就是可以通过字符串来创建对象。
  反射机制是在程序运行中，对于任意一个类，都能知道这个类的所有属性和方法，我们主要用于在运行时加载、探知、使用编译期间完全为止的class
  Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods
  反射API，有非常多的方法，这些方法通常定义在kernel、Object、Module中
  ruby中强大和最直接的反射特性之一就是eval方法
  通过反射我们可以做什么呢？这是个问题
  在ruby中通过字符串的名称来创建类Object::const_get('String').new()
  元编程，一般在某种本质上是扩展ruby的句法和行为，通常涉及若干反射机制


ruby编程语言：
如果将一个方法定义在类或模块之外，那么他就是一个全局函数，而不是一个方法（需通过某个对象来调用方法）。但是从技术角度来说，一个这样的方法会成为Object类的私有方法
===操作符也常常被称为条件相等性操作符，主要用来测试匹配性和从属关系，通常被case语句使用
::通常是来引用类方法的标识，而#是指引用实例方法的标识
使用=begin开头=end结尾可以注释一块代码快，=必须作为该行的第一个字符
here document以<<
或<<-开头，后面紧跟一个用于指定结尾分界符的标识符和字符串，从下行开始直到该分界符单独出现在一行为止
调用方法是需要给出方法名，及所在对象（有时称为接收者）
函数（没有关联对象）、方法（需要有一个接受者对象），因为ruby是一种纯粹的面向对象的语言，所以说所有的方法都是真正的方法，至少会有一个对象与之关联
用一个Proc对象代表一个代码块。有两种方式的Proc对象，一种被称为proc，另一种被称为lambda
方法别名：alias new_name existing_name
闭包：表示一个对象既是一个可调用的函数，同时也是绑定在这个函数上的变量。
proc对象的binding方法，会返回一个Binding对象
使用Binding对象和eval方法可以让我们获取一个操控闭包行为的后门eval("n=3",doubler.binding)

ruby元编程（或者说反射）能力相当强大，方法也可以用Method类的实例来表示，Method对象也用call调用

如果m是一个私有方法，那么只能用m这种方式来调用它，而不能用o.m或self.m来调用它
如果单独使用super，不带参数和圆括号，会使用所有当前方法的参数对超类的方法进行调用。如果当前方法修改了参数的值，那么传递给超类的方法是修改后的值

实例变量和类实例变量不能继承

类变量可以被继承，常量与实例方法类似，可以被继承和覆盖
使用private_class_method:来定义类私有方法，使用private：来定义实例方法
给某个对象增加一个方法，但并非给这个类增加一个方法，这种方式被称为单键方法
模块与类类似，但是模块不能被实例化，也不能被子类化，模块是独立的，在继承体系中没有所谓的任何“模块等级’，模块可以作为命名空间和mixin使用

单例模式在ruby中的使用方法：


问题：
ruby中的二维数组的扩展问题？
