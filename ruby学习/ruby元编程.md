### 第二章：方法（消除方法的重复性）
- 动态调用方法
	- 使用Object#send()来调用方法。这种技术称为动态派发。
- 动态定义方法
	- 利用Module#define_method()方法定义一个方法，只需要为其提供一个方法名和一个充当方法主体的块即可。一般使用其代替def关键字来定义方法
- 使用method_missing()方法
	- 通过覆盖method_missing方法来解决问题
	- Module#const_missing()方法，当引用一个不存在的常量时，ruby将这个常量名作为符号传递给它。
	- 白板类：删除继承来的方法，使其只包含需要的方法。从BasicObject继承来的类会自动成为白板类。
	- Module#undef_method()方法删除所有的方法（包括继承），Module#remove_method()方法，只会删除接收者自己的方法。
	- 动态代理(dynamic proxy)
	| 一个捕获幽灵方法调用并把它们转发给另外一个对象的对象，称为动态代理

### 第三章：代码块(**块是一种控制作用域的强大手段**)
- 查看当前方法是否包含块，Kernel#block_given?()方法来做到。
- 当定义一个块时，它会获取当时环境中的绑定，并且把它传递给一个方法时，它会带着这些绑定一起进入方法。
- 一般把块称为闭包，意味着一个块可以获取局部绑定，并一直带着它们。
- 一旦进入新的作用域，原先的绑定就会被替换为一组新的绑定
- 作用域门：类定义，模块定义，方法
- 在类和模块定义的代码会被立即执行，相反，方法定义的代码只有在方法被调用时被执行。
- 扁平化作用域：
- 使用Class.new()来代替class关键字
- 使用Module#define_method()方法来代替def
- Object#instance_eval(),把instance_eval()方法的块称为一个(**上下文探针**),因为它就像是深入到对象中的代码片段，对其进行操作。
- 存储一个块供以后使用：lambda(),proc(),Proc.new()
- 在lambda中的return是从当前的lambda中返回，而proc则是从定义proc的作用域中返回
- 可以使用Method#to_proc()方法把Method对象转换为Proc对象 
